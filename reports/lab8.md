# Lab 8

这个实验的要求真的是很难以理解了。

主要是这个实验给出的是一种理想的情况，因为可以拿到所有线程的需求矩阵。实际情况下需求矩阵并不好获得，尤其是我们要依托于现有的API接口来获取这个信息。

经过反复思考以及与描述对照之后，终于得到一个还算可行的解决方案。原理就是资源向量`Available`是创建信号量的大小，然后如果请求的时候有相应的资源则按直接分配处理，对应的资源转移到分配矩阵`Allocation`中。如果资源不够的话则进入我们的死锁检测。

这里死锁检测有两个重要的前提，
一个是所有线程申请的资源在运行结束后都会全部释放。虽然实际情况有可能忘了释放，我们现在也不知道最终会不会被释放，不过只有这样假设才有办法进行检测，并且测试样例也都能保证这种情况。
另一个是目前在不知道其它线程还会不会需要更多的资源的情况下，假定其它线程不需要更多资源就能继续运行到资源释放。因为其他线程还没有资源相关的系统调用，我们无从得知具体的情况，这样的假定也未必正确，不过当检测过的线程多了之后，如果出现死锁在检测后面的线程的时候是可以检测出来的。

然后就是按照题目所说的方法进行检查。如果检查成功了，则在目前的假定下该进程可以获得相应资源。不过因为后一个假定未必正确，所以就要跟真实分配的资源有所区分，把需求放到需求矩阵`Need`里。

但如果假定成功，线程真实分配到相应资源的时候，是不会有相应的系统调用的，所以我们也不能及时把`Need`里的资源转移到`Allocation`里。不过如果我们进入到了资源释放环境，则说明前面的过程都已经走完了，直接这个时候一起处理就可以了。

相应的检测程序目前只考虑了每个线程放到需求矩阵里的只有一种资源，没想清楚如果每个线程同时需要多种资源的话这个处理方法会不会出现问题。不过反正测试样例都是只有一种资源的情况，就不深入研究了。

注意目前的死锁检测算法不能正确处理将信号量用于条件同步的情况。不过毕竟是有`enable_deadlock_detect`这个开关在的，目前的死锁检测算法至少对提供的三个样例都是能够正常工作的。

上面的这几个向量和矩阵，为了便于处理我直接使用定长的数组进行存储了。实际最好应该用`Vector`，不过还要各种`resize`，想想挺麻烦的。试着搜了搜有没有包装好的可以自动`resize`的`Vector`库，好像没搜到特别有名的。

另外这个实验还有一个大坑。说是“本次实验不要求合并之前的实验内容”，但其实样例会调用`sleep`这个函数，而这个函数底层使用的`sys_get_time`这个系统调用，而这个系统调用在本lab中没实现。。。这个错还很隐蔽，表现就是一直死循环，不在关键的地方加打印语句根本看不出来。。。或者把`trace!`打开？不过我把所有实验都做完了还不知道怎么能看到`trace!`的输出结果😅
